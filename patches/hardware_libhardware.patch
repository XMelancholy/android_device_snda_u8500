#
#	new file:   hardware/libhardware/include/hardware/copybit.h
#	modified:   hardware/libhardware/include/hardware/fb.h
#	new file:   hardware/libhardware/include/hardware/fmradio.h
#	modified:   hardware/libhardware/include/hardware/hwcomposer.h
#
diff --git a/hardware/libhardware/include/hardware/copybit.h b/hardware/libhardware/include/hardware/copybit.h
new file mode 100755
index 0000000..93547b7
--- /dev/null
+++ b/hardware/libhardware/include/hardware/copybit.h
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_COPYBIT_INTERFACE_H
+#define ANDROID_COPYBIT_INTERFACE_H
+
+#include <hardware/hardware.h>
+
+#include <stdint.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+__BEGIN_DECLS
+
+/**
+ * The id of this module
+ */
+#define COPYBIT_HARDWARE_MODULE_ID "copybit"
+
+/**
+ * Name of the graphics device to open
+ */
+#define COPYBIT_HARDWARE_COPYBIT0 "copybit0"
+
+/* supported pixel-formats. these must be compatible with
+ * graphics/PixelFormat.java, ui/PixelFormat.h, pixelflinger/format.h
+ */
+enum {
+    COPYBIT_FORMAT_RGBA_8888    = HAL_PIXEL_FORMAT_RGBA_8888,
+    COPYBIT_FORMAT_RGBX_8888    = HAL_PIXEL_FORMAT_RGBX_8888,
+    COPYBIT_FORMAT_RGB_888      = HAL_PIXEL_FORMAT_RGB_888,
+    COPYBIT_FORMAT_RGB_565      = HAL_PIXEL_FORMAT_RGB_565,
+    COPYBIT_FORMAT_BGRA_8888    = HAL_PIXEL_FORMAT_BGRA_8888,
+    COPYBIT_FORMAT_RGBA_5551    = HAL_PIXEL_FORMAT_RGBA_5551,
+    COPYBIT_FORMAT_RGBA_4444    = HAL_PIXEL_FORMAT_RGBA_4444,
+    COPYBIT_FORMAT_YCbCr_422_SP = HAL_PIXEL_FORMAT_YCbCr_422_SP,
+    COPYBIT_FORMAT_YCbCr_420_SP = HAL_PIXEL_FORMAT_YCbCr_420_SP,
+    COPYBIT_FORMAT_YCbCr_422_P  = HAL_PIXEL_FORMAT_YCbCr_422_P,
+    COPYBIT_FORMAT_YCbCr_420_P  = HAL_PIXEL_FORMAT_YCbCr_420_P,
+    COPYBIT_FORMAT_YCrCb_422_SP = HAL_PIXEL_FORMAT_YCrCb_422_SP,
+    COPYBIT_FORMAT_YCrCb_420_SP = HAL_PIXEL_FORMAT_YCrCb_420_SP,
+    COPYBIT_FORMAT_YCrCb_422_P  = HAL_PIXEL_FORMAT_YCrCb_422_P,
+    COPYBIT_FORMAT_YCrCb_420_P  = HAL_PIXEL_FORMAT_YCrCb_420_P,
+    /* STE: Added Support for YUV42XMBN, required for Copybit CC acceleration */
+    COPYBIT_FORMAT_YCBCR42XMBN  = HAL_PIXEL_FORMAT_YCBCR42XMBN,
+    /* STE: Added for YCbCr422R -> RGB888 use-case */
+    COPYBIT_FORMAT_YCbCr_422_I  = HAL_PIXEL_FORMAT_YCbCr_422_I,
+};
+
+/* name for copybit_set_parameter */
+enum {
+    /* rotation of the source image in degrees (0 to 359) */
+    COPYBIT_ROTATION_DEG    = 1,
+    /* plane alpha value */
+    COPYBIT_PLANE_ALPHA     = 2,
+    /* enable or disable dithering */
+    COPYBIT_DITHER          = 3,
+    /* transformation applied (this is a superset of COPYBIT_ROTATION_DEG) */
+    COPYBIT_TRANSFORM       = 4,
+    /* blurs the copied bitmap. The amount of blurring cannot be changed
+     * at this time. */
+    COPYBIT_BLUR            = 5
+};
+
+/* values for copybit_set_parameter(COPYBIT_TRANSFORM) */
+enum {
+    /* flip source image horizontally */
+    COPYBIT_TRANSFORM_FLIP_H    = HAL_TRANSFORM_FLIP_H,
+    /* flip source image vertically */
+    COPYBIT_TRANSFORM_FLIP_V    = HAL_TRANSFORM_FLIP_V,
+    /* rotate source image 90 degres */
+    COPYBIT_TRANSFORM_ROT_90    = HAL_TRANSFORM_ROT_90,
+    /* rotate source image 180 degres */
+    COPYBIT_TRANSFORM_ROT_180   = HAL_TRANSFORM_ROT_180,
+    /* rotate source image 270 degres */
+    COPYBIT_TRANSFORM_ROT_270   = HAL_TRANSFORM_ROT_270,
+};
+
+/* enable/disable value copybit_set_parameter */
+enum {
+    COPYBIT_DISABLE = 0,
+    COPYBIT_ENABLE  = 1
+};
+
+/* use get_static_info() to query static informations about the hardware */
+enum {
+    /* Maximum amount of minification supported by the hardware*/
+    COPYBIT_MINIFICATION_LIMIT  = 1,
+    /* Maximum amount of magnification supported by the hardware */
+    COPYBIT_MAGNIFICATION_LIMIT = 2,
+    /* Number of fractional bits support by the scaling engine */
+    COPYBIT_SCALING_FRAC_BITS   = 3,
+    /* Supported rotation step in degres. */
+    COPYBIT_ROTATION_STEP_DEG   = 4,
+};
+
+/* Image structure */
+struct copybit_image_t {
+    /* width */
+    uint32_t    w;
+    /* height */
+    uint32_t    h;
+    /* format COPYBIT_FORMAT_xxx */
+    int32_t     format;
+    /* base of buffer with image */
+    void        *base;
+    /* handle to the image */
+    native_handle_t* handle;
+};
+
+/* Rectangle */
+struct copybit_rect_t {
+    /* left */
+    int l;
+    /* top */
+    int t;
+    /* right */
+    int r;
+    /* bottom */
+    int b;
+};
+
+/* Color (components in range 0-255) */
+struct copybit_color_t {
+    /* Red */
+    uint8_t r;
+    /* Green */
+    uint8_t g;
+    /* Blue */
+    uint8_t b;
+    /* Alpha */
+    uint8_t a;
+};
+
+/* Region */
+struct copybit_region_t {
+    int (*next)(struct copybit_region_t const *region, struct copybit_rect_t *rect);
+};
+
+/**
+ * Every hardware module must have a data structure named HAL_MODULE_INFO_SYM
+ * and the fields of this data structure must begin with hw_module_t
+ * followed by module specific information.
+ */
+struct copybit_module_t {
+    struct hw_module_t common;
+};
+
+/**
+ * Every device data structure must begin with hw_device_t
+ * followed by module specific public methods and attributes.
+ */
+struct copybit_device_t {
+    struct hw_device_t common;
+
+    /**
+     * Set a copybit parameter.
+     *
+     * @param dev from open
+     * @param name one for the COPYBIT_NAME_xxx
+     * @param value one of the COPYBIT_VALUE_xxx
+     *
+     * @return 0 if successful
+     */
+    int (*set_parameter)(struct copybit_device_t *dev, int name, int value);
+
+    /**
+     * Get a static copybit information.
+     *
+     * @param dev from open
+     * @param name one of the COPYBIT_STATIC_xxx
+     *
+     * @return value or -EINVAL if error
+     */
+    int (*get)(struct copybit_device_t *dev, int name);
+
+    /**
+     * Execute the bit blit copy operation
+     *
+     * @param dev from open
+     * @param dst is the destination image
+     * @param src is the source image
+     * @param region the clip region
+     *
+     * @return 0 if successful
+     */
+    int (*blit)(struct copybit_device_t *dev,
+                struct copybit_image_t const *dst,
+                struct copybit_image_t const *src,
+                struct copybit_region_t const *region);
+
+    /**
+     * Execute the stretch bit blit copy operation
+     *
+     * @param dev from open
+     * @param dst is the destination image
+     * @param src is the source image
+     * @param dst_rect is the destination rectangle
+     * @param src_rect is the source rectangle
+     * @param region the clip region
+     *
+     * @return 0 if successful
+     */
+    int (*stretch)(struct copybit_device_t *dev,
+                   struct copybit_image_t const *dst,
+                   struct copybit_image_t const *src,
+                   struct copybit_rect_t const *dst_rect,
+                   struct copybit_rect_t const *src_rect,
+                   struct copybit_region_t const *region);
+
+    /**
+     * Execute the fill bit blit operation
+     *
+     * @param dev from open
+     * @param dst is the destination image
+     * @param rect is the destination rectangle
+     * @param color is the fill color
+     * @param region the clip region
+     */
+    int (*fill)(struct copybit_device_t *dev,
+                struct copybit_image_t *dst,
+                struct copybit_rect_t *rect,
+                struct copybit_color_t *color,
+                struct copybit_region_t *region);
+};
+
+
+/** convenience API for opening and closing a device */
+
+static inline int copybit_open(const struct hw_module_t* module,
+        struct copybit_device_t** device) {
+    return module->methods->open(module,
+            COPYBIT_HARDWARE_COPYBIT0, (struct hw_device_t**)device);
+}
+
+static inline int copybit_close(struct copybit_device_t* device) {
+    return device->common.close(&device->common);
+}
+
+
+__END_DECLS
+
+#endif  // ANDROID_COPYBIT_INTERFACE_H
diff --git a/hardware/libhardware/include/hardware/fb.h b/hardware/libhardware/include/hardware/fb.h
index ba2f286..45c0393 100644
--- a/hardware/libhardware/include/hardware/fb.h
+++ b/hardware/libhardware/include/hardware/fb.h
@@ -42,18 +42,32 @@ typedef struct framebuffer_device_t {
     const uint32_t  flags;
 
     /* dimensions of the framebuffer in pixels */
+#ifdef STE_HARDWARE
+    uint32_t  width;
+    uint32_t  height;
+#else
     const uint32_t  width;
     const uint32_t  height;
+#endif
 
     /* frambuffer stride in pixels */
+#ifdef STE_HARDWARE
+    int       stride;
+#else
     const int       stride;
+#endif
 
     /* framebuffer pixel format */
     const int       format;
 
     /* resolution of the framebuffer's display panel in pixel per inch*/
+#ifdef STE_HARDWARE
+    float     xdpi;
+    float     ydpi;
+#else
     const float     xdpi;
     const float     ydpi;
+#endif
 
     /* framebuffer's display panel refresh rate in frames per second */
     const float     fps;
@@ -140,7 +154,26 @@ typedef struct framebuffer_device_t {
      * Returns 0 on success or -errno on error.
      */
     int (*enableScreen)(struct framebuffer_device_t* dev, int enable);
+#ifdef STE_HARDWARE
+    /*
+     * Sets the number of degrees ccw the framebuffer shall be rotated before
+     * being sent to the display. This call may change the framebuffer's
+     * dimensions.
+     */
+    int (*rotate)(struct framebuffer_device_t* dev, unsigned int absolute_degree);
 
+    /*
+     * Informs gralloc about the UI rotation. This is needed in the mirroring use
+     * case to get the correct orientation on the external device, e.g. HDMI.
+     */
+    void (*UIRotationChange)(struct framebuffer_device_t* dev, int uiRotation);
+
+    /*
+     * Enables the mirroring of the main display content to an external device,
+     * e.g. HDMI.
+     */
+    void (*enableHDMIMirroring)(struct framebuffer_device_t* dev, int enable);
+#endif
     void* reserved_proc[6];
 
 } framebuffer_device_t;
diff --git a/hardware/libhardware/include/hardware/fmradio.h b/hardware/libhardware/include/hardware/fmradio.h
new file mode 100755
index 0000000..49b3ded
--- /dev/null
+++ b/hardware/libhardware/include/hardware/fmradio.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: johan.xj.palmaeus@stericsson.com for ST-Ericsson
+ */
+
+/*
+ * Interface file between the vendor specific drivers and the fmradio
+ * jni layer. The vendor driver need to define register function with
+ * name defined by FMRADIO_REGISTER_FUNC of type fmradio_reg_func_t that
+ * will return a pointer to a signature (FMRADIO_SIGNATURE) to make sure
+ * it executed correctly and fill struct fmradio_vendor_methods with
+ * functions implementing functions (or NULL if not supported).
+ */
+
+#ifndef ANDROID_FMRADIO_INTERFACE_H
+#define ANDROID_FMRADIO_INTERFACE_H
+
+__BEGIN_DECLS
+
+#define FMRADIO_REGISTER_FUNC "register_fmradio_functions"
+
+#define FMRADIO_SIGNATURE 0xDEADBABE
+
+#define FMRADIO_CAPABILITY_RECEIVER 0x0001
+#define FMRADIO_CAPABILITY_TRANSMITTER 0x0002
+#define FMRADIO_CAPABILITY_TUNER_WRAP_AROUND 0x0004
+#define FMRADIO_CAPABILITY_RDS_SUPPORTED 0x0008
+
+/*
+ * return values. Not defined as enum since some functions either
+ * return a positive value or these codes, like getFrequency.
+ */
+#define  FMRADIO_OK 0
+#define  FMRADIO_INVALID_STATE -1       /* internally in jni layer */
+#define  FMRADIO_UNSUPPORTED_OPERATION -2
+#define  FMRADIO_IO_ERROR -3
+#define  FMRADIO_INVALID_PARAMETER -4
+#define  FMRADIO_FORCED_RESET -5
+
+/* RDS */
+#define RDS_MAX_AFS 25
+#define RDS_PSN_MAX_LENGTH 8
+#define RDS_RT_MAX_LENGTH 64
+#define RDS_CT_MAX_LENGTH 14
+#define RDS_PTYN_MAX_LENGTH 8
+#define RDS_NUMBER_OF_TMC 3
+
+enum fmradio_band_t {
+    FMRADIO_BAND_US,
+    FMRADIO_BAND_EU,
+    FMRADIO_BAND_JAPAN,
+    FMRADIO_BAND_CHINA
+};
+
+enum fmradio_seek_direction_t {
+    FMRADIO_SEEK_DOWN,
+    FMRADIO_SEEK_UP
+};
+
+enum fmradio_reset_reason_t {
+    FMRADIO_RESET_NON_CRITICAL = 0,
+    FMRADIO_RESET_CRITICAL,
+    FMRADIO_RESET_OTHER_IN_USE,    /* internally in jni layer */
+    FMRADIO_RESET_RADIO_FORBIDDEN, /* internally in java layer */
+};
+
+enum fmradio_extra_command_type_t {
+    FMRADIO_TYPE_INT,
+    FMRADIO_TYPE_STRING
+};
+
+enum fmradio_switch_reason_t {
+    FMRADIO_SWITCH_AF,
+    FMRADIO_SWITCH_TA,
+    FMRADIO_SWITCH_TA_END
+};
+
+union fmradio_extra_data_t {
+    int int_value;
+    char *string_value;
+};
+
+struct fmradio_rds_bundle_t {
+    unsigned short pi;
+    short tp;
+    short pty;
+    short ta;
+    short ms;
+    short num_afs;
+    int af[RDS_MAX_AFS];
+    char psn[RDS_PSN_MAX_LENGTH + 1];
+    char rt[RDS_RT_MAX_LENGTH + 1];
+    char ct[RDS_CT_MAX_LENGTH + 1];
+    char ptyn[RDS_PTYN_MAX_LENGTH + 1];
+    short tmc[RDS_NUMBER_OF_TMC];
+    int taf;
+};
+
+struct fmradio_extra_command_ret_item_t {
+    char *key;
+    enum fmradio_extra_command_type_t type;
+    union fmradio_extra_data_t data;
+};
+
+/* vendor callbacks only for RX */
+struct fmradio_vendor_callbacks_t {
+    void (*on_playing_in_stereo_changed) (int is_stereo);
+    void (*on_rds_data_found) (struct fmradio_rds_bundle_t * rds_bundle,
+                               int frequency);
+    void (*on_signal_strength_changed) (int new_level);
+    void (*on_automatic_switch) (int new_freq,
+                                 enum fmradio_switch_reason_t reason);
+    void (*on_forced_reset) (enum fmradio_reset_reason_t reason);
+};
+
+struct fmradio_vendor_methods_t {
+    int (*rx_start) (void ** session_data,
+                    const struct fmradio_vendor_callbacks_t * callbacks,
+                    int low_freq, int high_freq, int default_freq, int grid);
+    int (*tx_start) (void ** session_data,
+                    const struct fmradio_vendor_callbacks_t * callbacks,
+                    int low_freq, int high_freq, int default_freq, int grid);
+    int (*pause) (void ** session_data);
+    int (*resume) (void ** session_data);
+    int (*reset) (void ** session_data);
+    int (*set_frequency) (void ** session_data, int frequency);
+    int (*get_frequency) (void ** session_data);
+    int (*stop_scan) (void ** session_data);
+    int (*send_extra_command) (void ** session_data, const char * command,
+                             char ** parameters,
+                             struct fmradio_extra_command_ret_item_t ** out_parameters);
+    /* rx only */
+    int (*scan) (void ** session_data, enum fmradio_seek_direction_t direction);
+
+    int (*full_scan) (void ** session_data, int ** found_freqs,
+                     int ** signal_strenghts);
+    int (*get_signal_strength) (void ** session_data);
+    int (*is_playing_in_stereo) (void ** session_data);
+    int (*is_rds_data_supported) (void ** session_data);
+    int (*is_tuned_to_valid_channel) (void ** session_data);
+    int (*set_automatic_af_switching) (void ** session_data, int automatic);
+    int (*set_automatic_ta_switching) (void ** session_data, int automatic);
+    int (*set_force_mono) (void ** session_data, int force_mono);
+    int (*get_threshold) (void ** session_data);
+    int (*set_threshold) (void ** session_data, int threshold);
+    int (*set_rds_reception) (void ** session_data, int use_rds);
+    /* tx only */
+    int (*block_scan) (void ** session_data, int low_freq, int high_freq,
+                      int ** found_freqs, int ** signal_strenghts);
+    int (*set_rds_data) (void ** session_data, char * key, void * value);
+};
+
+typedef int (*fmradio_reg_func_t) (unsigned int * signature_p,
+                                   struct fmradio_vendor_methods_t * vendor_funcs_p);
+
+__END_DECLS
+
+#endif  // ANDROID_FMRADIO_INTERFACE_H
diff --git a/hardware/libhardware/include/hardware/hwcomposer.h b/hardware/libhardware/include/hardware/hwcomposer.h
index 98e665c..89ba6a4 100644
--- a/hardware/libhardware/include/hardware/hwcomposer.h
+++ b/hardware/libhardware/include/hardware/hwcomposer.h
@@ -77,7 +77,21 @@ typedef struct hwc_methods {
 
     int (*eventControl)(
             struct hwc_composer_device* dev, int event, int enabled);
+#ifdef STE_HARDWARE
+    /*************************************************************************
+     * HWC_DEVICE_API_VERSION_0_3_STE
+     *************************************************************************/
 
+    /*
+     * This hook is vendor specific and optional.
+     *
+     * (*setParameter)() makes the hardware composer aware of the system state,
+     * e.g. hdmi plug status and ui rotation, so that it can make intelligent
+     * decisions on how to handle composed surfaces and cloning in the kernel.
+     */
+    int (*setParameter)(struct hwc_composer_device* dev,
+                int param, int value);
+#endif
 } hwc_methods_t;
 
 typedef struct hwc_rect {
@@ -236,8 +250,19 @@ typedef struct hwc_procs {
 typedef struct hwc_module {
     struct hw_module_t common;
 } hwc_module_t;
-
-
+#ifdef STE_HARDWARE
+/*
+ * names for setParameter()
+ */
+enum {
+    /* Specifies the UI orientation */
+    HWC_UI_ORIENTATION = 0x00000000,
+    /* Specifies if hardware rotation is used */
+    HWC_HARDWARE_ROTATION = 0x00000001,
+    /* Set the hdmi plug status */
+    HWC_HDMI_PLUGGED = 0x00000002,
+};
+#endif
 typedef struct hwc_composer_device {
     struct hw_device_t common;
 
